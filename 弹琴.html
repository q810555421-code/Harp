<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Air Harp - 隔空演奏的彩色竖琴（灵敏优化版）</title>

  <!-- p5.js + p5.sound -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: "Helvetica Neue", Arial, sans-serif;
      user-select: none;
    }

    #ui-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(10px);
      z-index: 10;
      color: #fff;
      transition: opacity 0.35s ease;
    }

    h1 {
      font-weight: 200;
      letter-spacing: 6px;
      margin: 0 0 26px 0;
      text-shadow: 0 0 20px rgba(0,255,255,0.45);
    }

    #start-btn {
      padding: 15px 40px;
      font-size: 18px;
      background: linear-gradient(45deg, #00d2ff, #3a7bd5);
      border: none;
      border-radius: 30px;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 10px 20px rgba(0,210,255,0.25);
      transition: transform 0.15s, box-shadow 0.15s;
    }

    #start-btn:hover {
      transform: scale(1.04);
      box-shadow: 0 14px 28px rgba(0,210,255,0.45);
    }

    #start-btn:disabled {
      background: #555;
      cursor: not-allowed;
      box-shadow: none;
    }

    #loading {
      margin-top: 18px;
      font-size: 13px;
      color: #aaa;
      max-width: 640px;
      text-align: center;
      line-height: 1.5;
      padding: 0 18px;
      white-space: pre-line;
    }

    #controls {
      position: fixed;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 18px;
      z-index: 6;
      background: rgba(255,255,255,0.10);
      padding: 10px 18px;
      border-radius: 18px;
      backdrop-filter: blur(6px);
      align-items: center;
    }

    .control-item {
      color: #fff;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 10px;
      white-space: nowrap;
    }

    #fs-btn {
      padding: 6px 14px;
      font-size: 12px;
      border-radius: 10px;
      border: none;
      cursor: pointer;
      background: rgba(255,255,255,0.85);
      color: #000;
    }

    /* 调试用摄像头预览（默认半透明显示，便于你判断手是否在画面里） */
    #cam {
      position: fixed;
      right: 12px;
      top: 12px;
      width: 200px;
      height: 150px;
      opacity: 0.35;         /* 想隐藏改为 0 */
      pointer-events: none;
      z-index: 2;
      border-radius: 10px;
      overflow: hidden;
      transform: scaleX(-1); /* 镜像，符合用户直觉 */
    }
  </style>
</head>

<body>
  <!-- 启动界面 -->
  <div id="ui-overlay">
    <h1>AIR HARP</h1>
    <button id="start-btn" disabled>正在加载模型...</button>
    <div id="loading">首次加载可能需要 30–60 秒（取决于网络）。</div>
  </div>

  <!-- 底部控制栏 -->
  <div id="controls">
    <div class="control-item">
      <span>主音量</span>
      <input type="range" id="vol-slider" min="0" max="1" step="0.01" value="0.5" />
    </div>
    <div class="control-item">
      <button id="fs-btn">全屏</button>
    </div>
  </div>

  <!-- 摄像头视频（给 mediapipe 取帧 + 你调试用） -->
  <video id="cam" playsinline muted></video>

  <!-- MediaPipe Tasks Vision（module） -->
  <script type="module">
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    let handLandmarker;
    const videoEl = document.getElementById("cam");
    let lastVideoTime = -1;

    // 暴露给 p5
    window.handData = null;
    window.isModelLoaded = false;

    const startBtn = document.getElementById("start-btn");
    const loadingEl = document.getElementById("loading");

    async function createHandLandmarker() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );

        // 注意：该地址在部分网络环境会不可达
        const modelUrl =
          "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";

        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: modelUrl,
            delegate: "GPU",
          },
          runningMode: "VIDEO",
          numHands: 2,
        });

        window.isModelLoaded = true;
        startBtn.disabled = false;
        startBtn.innerText = "点击开始演奏";
        loadingEl.style.display = "none";
        console.log("[Model] loaded");
      } catch (e) {
        console.error("[Model] load failed:", e);
        // 允许进入，但关闭手追踪
        startBtn.disabled = false;
        startBtn.innerText = "开始演奏（无手追踪）";
        loadingEl.innerText =
          "模型加载失败：常见原因是无法访问 Google Storage。\n你仍可进入界面，但不会有手势识别。\n解决：换网络/开代理/或把模型下载到本地并改成相对路径。";
      }
    }

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
        audio: false,
      });

      videoEl.srcObject = stream;
      videoEl.playsInline = true;
      videoEl.muted = true;

      await videoEl.play();
      console.log("[Camera] started:", videoEl.videoWidth, videoEl.videoHeight);

      requestAnimationFrame(predictLoop);
    }

    function predictLoop() {
      if (!handLandmarker) return;

      if (!videoEl || videoEl.readyState < 2) {
        requestAnimationFrame(predictLoop);
        return;
      }

      const now = performance.now();
      if (videoEl.currentTime !== lastVideoTime) {
        lastVideoTime = videoEl.currentTime;
        try {
          const res = handLandmarker.detectForVideo(videoEl, now);
          window.handData = res;
        } catch (e) {
          console.error("[Detect] error:", e);
        }
      }

      requestAnimationFrame(predictLoop);
    }

    window.startCamera = startCamera;
    createHandLandmarker();
  </script>

  <!-- p5 核心逻辑（已针对“单指不灵/握拳反而灵”做优化） -->
  <script>
    /**********************************************************
     * 关键优化点（针对你说的“单食指没反应、握拳反而有反应”）
     * 1) 不再用 landmark[8]（食指指尖）作为触发点
     *    改用更稳定的 hand anchor 点：landmark[9]（中指 MCP）
     * 2) 对手的 x,y 做指数平滑（EMA），减少抖动与丢点
     * 3) 触发阈值更“workshop友好”：更低速度门槛、更大距离容错、更短防抖
     **********************************************************/

    /***********************
     * UI 启动逻辑（保证按钮一定可点）
     ***********************/
    document.addEventListener("DOMContentLoaded", () => {
      const startBtn = document.getElementById("start-btn");
      const overlay = document.getElementById("ui-overlay");
      const controls = document.getElementById("controls");
      const volSlider = document.getElementById("vol-slider");
      const fsBtn = document.getElementById("fs-btn");

      startBtn.addEventListener("click", async () => {
        console.log("[UI] start clicked");

        // 解锁音频（必须用户手势）
        try { if (window.userStartAudio) userStartAudio(); } catch (e) {}

        // 启动摄像头
        try {
          if (window.startCamera) await window.startCamera();
        } catch (e) {
          console.error(e);
          alert("无法启动摄像头，请检查浏览器权限或是否被其他软件占用。");
        }

        overlay.style.opacity = 0;
        setTimeout(() => {
          overlay.style.display = "none";
          overlay.style.pointerEvents = "none";
        }, 350);

        controls.style.display = "flex";

        volSlider.addEventListener("input", (e) => {
          window.masterVol = parseFloat(e.target.value);
        });

        fsBtn.addEventListener("click", () => {
          const fs = document.fullscreenElement;
          if (!fs) document.documentElement.requestFullscreen?.();
          else document.exitFullscreen?.();
        });

        window.isStarted = true;
      });
    });

    /***********************
     * Harp / 音频逻辑
     ***********************/
    const STRINGS_COUNT = 24;
    const NOTES = [
      "C3","D3","E3","F3","G3","A3","B3",
      "C4","D4","E4","F4","G4","A4","B4",
      "C5","D5","E5","F5","G5","A5","B5",
      "C6","D6","E6"
    ];

    window.masterVol = 0.5;
    window.isStarted = false;

    function noteToFreq(note) {
      const mapN = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
      const n = note.slice(0, -1);
      const octave = parseInt(note.slice(-1), 10);
      const semitone = mapN[n] + octave * 12;
      const midi = semitone + 12; // C0=12
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    const TENSION = 0.05;
    const DAMPING = 0.92;

    let strings = [];
    let filter;
    let activeNote = "";

    // 触发参数（你要更灵敏就再调小/调大）
    const SPEED_THRESHOLD = 0.12;  // 原本更大；现在更容易触发
    const DIST_THRESHOLD  = 30;    // 容错更大
    const DEBOUNCE_MS     = 70;    // 更短，响应更快

    // 平滑参数（越接近 1 越“稳但迟钝”，越小越“灵但抖”）
    const SMOOTH_ALPHA = 0.35;

    // 用于速度估计
    let smoothX = null, smoothY = null;
    let lastX = null, lastT = null;

    class HarpString {
      constructor(x, index) {
        this.baseX = x;
        this.x = x;
        this.vx = 0;
        this.index = index;

        this.color = null;
        this.freq = noteToFreq(NOTES[index]);
        this.isPlaying = false;

        this.osc = new p5.Oscillator("sine");
        this.osc.freq(this.freq);
        this.osc.amp(0);

        this.env = new p5.Envelope();
        this.env.setADSR(0.01, 0.2, 0.1, 0.5);
        this.env.setRange(0.8, 0.001);
      }

      startAudio() {
        this.osc.start();
        this.osc.disconnect();
        this.osc.connect(filter);
      }

      update() {
        const force = (this.baseX - this.x) * TENSION;
        this.vx += force;
        this.vx *= DAMPING;
        this.x += this.vx;

        if (Math.abs(this.x - this.baseX) < 0.1 && Math.abs(this.vx) < 0.1) {
          this.x = this.baseX;
          this.vx = 0;
        }
      }

      draw() {
        noFill();

        const b = this.isPlaying ? 100 : 65;
        const w = this.isPlaying ? 4 : 2 + Math.abs(this.baseX - this.x) * 0.1;

        strokeWeight(w);

        if (this.isPlaying) {
          stroke(hue(this.color), 60, 100, 160);
          line(this.x, 0, this.x, height);
        }

        stroke(hue(this.color), saturation(this.color), b);
        beginShape();
        curveVertex(this.baseX, 0);
        curveVertex(this.baseX, 0);
        curveVertex(this.x, height / 2);
        curveVertex(this.baseX, height);
        curveVertex(this.baseX, height);
        endShape();
      }

      pluck(vxRatio, yRatio) {
        const direction = vxRatio >= 0 ? 1 : -1;
        this.vx = 30 * direction;

        const dynamicVol = constrain(1 - yRatio, 0.2, 1);
        const vol = dynamicVol * (window.masterVol ?? 0.5);

        this.env.setRange(vol, 0.001);
        this.env.play(this.osc, 0, 0.1);

        this.isPlaying = true;
        activeNote = NOTES[this.index];
        setTimeout(() => (this.isPlaying = false), 160);
      }
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100);

      filter = new p5.LowPass();
      filter.freq(900);
      filter.res(6);

      const spacing = width / (STRINGS_COUNT + 1);
      strings = [];
      for (let i = 0; i < STRINGS_COUNT; i++) {
        const s = new HarpString(spacing * (i + 1), i);
        s.color = color(map(i, 0, STRINGS_COUNT, 0, 300), 80, 80);
        strings.push(s);
      }
    }

    function draw() {
      setGradient(0, 0, width, height, color(210, 80, 10), color(220, 80, 35));

      // 启动后再开振荡器（避免浏览器限制）
      if (window.isStarted && !draw._audioStarted) {
        try {
          strings.forEach(s => s.startAudio());
          draw._audioStarted = true;
        } catch (e) {}
      }

      for (const s of strings) {
        s.update();
        s.draw();
      }

      handleHandsOptimized();
      drawHUD();
    }

 function handleHandsOptimized() {
  if (!window.isStarted) return;

  const hd = window.handData;
  if (!hd?.landmarks?.length) return;

  const lm = hd.landmarks[0];
  const anchor = lm?.[9];
  if (!anchor) return;

  // 与 #cam scaleX(-1) 对齐
  const xNorm = 1 - anchor.x;
  const yNorm = anchor.y;

  const px = xNorm * width;
  const py = yNorm * height;

  // 平滑（EMA）
  if (smoothX == null) {
    smoothX = px; smoothY = py;
    lastX = smoothX; lastT = performance.now();
    return;
  } else {
    smoothX = smoothX * (1 - SMOOTH_ALPHA) + px * SMOOTH_ALPHA;
    smoothY = smoothY * (1 - SMOOTH_ALPHA) + py * SMOOTH_ALPHA;
  }

  // 速度
  const now = performance.now();
  const dt = Math.max(1, now - lastT);
  const vx = (smoothX - lastX) / dt; // px/ms
  lastX = smoothX; lastT = now;

  // 速度太小，不拨
  if (Math.abs(vx) < SPEED_THRESHOLD) return;

  // —— 核心：跨线触发 —— 
  // 用上一帧位置和当前帧位置，判断是否穿过某根弦的 baseX
  const prevX = smoothX - vx * dt; // 近似上一帧位置（也可另存 prevSmoothX 更严谨）
  const currX = smoothX;

  // 允许的“穿过误差”（越大越灵敏，但可能误触）
  const CROSS_EPS = 6;

  // 为了支持“跳着拨”，这里不再用“最近弦”，而是检查你是否跨过某根弦
  for (const s of strings) {
    const sx = s.baseX;

    const crossed =
      (prevX < sx - CROSS_EPS && currX > sx + CROSS_EPS) ||
      (prevX > sx + CROSS_EPS && currX < sx - CROSS_EPS);

    if (!crossed) continue;

    // 防抖：同一根弦短时间内不重复
    const nowMs = performance.now();
    if (s._lastPluck && (nowMs - s._lastPluck) < DEBOUNCE_MS) continue;

    s._lastPluck = nowMs;
    s.pluck(vx, yNorm);
    break; // 一次移动最多触发一根弦，避免连响
  }

  // 调试点（可留）
  noStroke();
  fill(0, 0, 100, 80);
  circle(smoothX, smoothY, 10);
}


    function drawHUD() {
      noStroke();
      fill(0, 0, 100, 80);
      textAlign(LEFT, TOP);
      textSize(22);
      text("AIR HARP", 18, 16);

      textSize(12);
      fill(0, 0, 100, 60);
      const status = window.isModelLoaded ? "Hand tracking: ON" : "Hand tracking: OFF";
      text(status, 18, 44);

      if (activeNote) {
        textSize(14);
        fill(0, 0, 100, 85);
        text("Now: " + activeNote, 18, 64);
      }

      // 提示：用锚点 9 后，你“握拳/半握/单指”都能更稳定触发
      textSize(12);
      fill(0, 0, 100, 50);
      text("提示：手掌完整进入画面、避免背光；半握拳/食指伸出都可。", 18, 86);
    }

    function setGradient(x, y, w, h, c1, c2) {
      for (let i = y; i <= y + h; i++) {
        const inter = map(i, y, y + h, 0, 1);
        const c = lerpColor(c1, c2, inter);
        stroke(c);
        line(x, i, x + w, i);
      }
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      const spacing = width / (STRINGS_COUNT + 1);
      for (let i = 0; i < strings.length; i++) {
        strings[i].baseX = spacing * (i + 1);
      }
    }
  </script>

  <!--
    如果你一直“模型加载失败”，是因为 hand_landmarker.task 在 storage.googleapis.com 上，
    你的网络无法访问时会失败。

    解决：
    1) 换网络/开代理
    2) 下载模型到本地，例如 ./models/hand_landmarker.task
       然后把 module 里的 modelUrl 改成：
       const modelUrl = "./models/hand_landmarker.task";
  -->
</body>
</html>
